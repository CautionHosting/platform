// SPDX-FileCopyrightText: 2025 Caution SEZC
// SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-Commercial

use anyhow::{Context, Result};
use std::path::{Path, PathBuf};
use tokio::fs;
use tokio::process::Command;

#[deprecated = "unused"]
pub async fn build_combined_image(
    template_source: &str,
    template_version: &str,
    user_fs_path: PathBuf,
    output_tag: &str,
    work_dir: &Path,
) -> Result<String> {
    tracing::info!("Building combined enclave image");

    let template_dir = if template_source.starts_with("http") || template_source.starts_with("git@") {
        clone_template(template_source, template_version, work_dir).await?
    } else {
        PathBuf::from(template_source)
    };

    let build_dir = work_dir.join("combined-build");
    fs::create_dir_all(&build_dir).await?;

    let dockerfile = generate_combining_dockerfile(&template_dir, &user_fs_path)?;
    let dockerfile_path = build_dir.join("Dockerfile");
    fs::write(&dockerfile_path, dockerfile).await?;

    let startup_script = r#"#!/bin/sh
/usr/local/bin/attestation-service &
sleep 2
cd /user-service
for exe in $(find /user-service/usr/local/bin -type f -executable 2>/dev/null); do
    exec "$exe"
done
echo "No executable found in user service"
exit 1
"#;
    let startup_script_path = build_dir.join("startup.sh");
    fs::write(&startup_script_path, startup_script).await?;

    copy_recursive(&user_fs_path, &build_dir.join("user-service")).await?;

    copy_recursive(&template_dir, &build_dir.join("template")).await?;

    let image_ref = build_docker_image(&build_dir, output_tag).await?;

    tracing::info!("Combined image built: {}", image_ref);
    Ok(image_ref)
}

async fn clone_template(repo_url: &str, version: &str, work_dir: &Path) -> Result<PathBuf> {
    tracing::info!("Cloning template from: {} @ {}", repo_url, version);

    let clone_dir = work_dir.join("template");
    fs::create_dir_all(&clone_dir).await?;

    let output = Command::new("git")
        .args(["clone", "--depth", "1", "--branch", version, repo_url])
        .arg(&clone_dir)
        .output()
        .await
        .context("Failed to clone template repository")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        anyhow::bail!("Failed to clone template: {}", stderr);
    }

    Ok(clone_dir)
}

#[allow(unused_variables)]
fn generate_combining_dockerfile(template_dir: &Path, user_fs_path: &Path) -> Result<String> {
    let dockerfile = format!(
        r#"# Combined enclave image: template + user service
# This Dockerfile is auto-generated by enclave-builder

# Build attestation service from template
FROM stagex/pallet-rust AS attestation-builder
WORKDIR /build
COPY template/ /build/
RUN cargo build --release --manifest-path=/build/src/attestation-service/Cargo.toml

# Build init from template
FROM stagex/pallet-rust AS init-builder
WORKDIR /build
COPY template/ /build/
RUN cargo build --release --manifest-path=/build/src/init/Cargo.toml

# Get busybox for shell support
FROM stagex/core-busybox AS busybox

# Final runtime image
FROM stagex/core-user-runtime AS runtime

# Copy busybox for shell support
COPY --from=busybox / /

# Copy built binaries from template
COPY --from=attestation-builder /build/target/release/attestation-service /usr/local/bin/
COPY --from=init-builder /build/target/release/init /usr/local/bin/

# Copy user service filesystem into isolated directory
COPY user-service/ /user-service/

# Copy startup script with executable permissions
COPY --chmod=755 startup.sh /usr/local/bin/startup.sh

# Set entrypoint to our startup script
ENTRYPOINT ["/usr/local/bin/startup.sh"]
"#
    );

    Ok(dockerfile)
}

async fn build_docker_image(build_dir: &Path, tag: &str) -> Result<String> {
    tracing::info!("Building Docker image with tag: {}", tag);

    let output = Command::new("docker")
        .args(["build", "-t", tag, "."])
        .current_dir(build_dir)
        .output()
        .await
        .context("Failed to execute docker build")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        anyhow::bail!("Docker build failed: {}", stderr);
    }

    Ok(tag.to_string())
}

async fn copy_recursive(src: &Path, dst: &Path) -> Result<()> {
    fs::create_dir_all(dst).await?;

    use walkdir::WalkDir;

    for entry in WalkDir::new(src) {
        let entry = entry?;
        let path = entry.path();
        let rel_path = path.strip_prefix(src)?;
        let dst_path = dst.join(rel_path);

        if entry.file_type().is_dir() {
            fs::create_dir_all(&dst_path).await?;
        } else {
            if let Some(parent) = dst_path.parent() {
                fs::create_dir_all(parent).await?;
            }
            fs::copy(path, &dst_path).await
                .with_context(|| format!("Failed to copy {} to {}", path.display(), dst_path.display()))?;
        }
    }

    Ok(())
}

pub async fn build_combined_with_buildkit(
    template_image: &str,
    user_fs_path: &Path,
    output_tag: &str,
) -> Result<String> {
    let dockerfile = format!(
        r#"# syntax=docker/dockerfile:1

# Start from the published template image
FROM {} AS template

# Copy user filesystem into isolated location
FROM template
COPY user-service/ /user-service/

# Create unified startup script
RUN printf '#!/bin/sh\n\
/usr/local/bin/attestation-service &\n\
sleep 2\n\
cd /user-service && exec /user-service/app\n' \
> /usr/local/bin/startup.sh && chmod +x /usr/local/bin/startup.sh

ENTRYPOINT ["/usr/local/bin/startup.sh"]
"#,
        template_image
    );

    let temp_dir = tempfile::tempdir()?;
    let build_dir = temp_dir.path();

    fs::write(build_dir.join("Dockerfile"), dockerfile).await?;
    copy_recursive(user_fs_path, &build_dir.join("user-service")).await?;

    let output = Command::new("docker")
        .env("DOCKER_BUILDKIT", "1")
        .args(["build", "-t", output_tag, "."])
        .current_dir(build_dir)
        .output()
        .await?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        anyhow::bail!("Docker BuildKit build failed: {}", stderr);
    }

    Ok(output_tag.to_string())
}
